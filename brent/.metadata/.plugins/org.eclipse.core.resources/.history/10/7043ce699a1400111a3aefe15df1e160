import java.nio.ByteBuffer;
import java.nio.charset.Charset;
import java.nio.charset.CharsetDecoder;

import org.apache.cassandra.thrift.*;
import org.apache.thrift.protocol.TProtocol;
import org.apache.thrift.transport.TFramedTransport;
import org.apache.thrift.transport.TTransport;
import org.apache.thrift.transport.TSocket;


public class tcq {
	
	// Connection variables
	static private TTransport transport;
	static private TProtocol protocol;
	static private Cassandra.Client client;
	
	static private String host;
	
	// Set up the decoder
	static CharsetDecoder decoder = Charset.forName("UTF-8").newDecoder();
	
	
	public static void main(String[] args) throws Exception {

		if (args.length == 1)
			host = args[0];
		
		// Set up connection.
		transport = new TFramedTransport(new TSocket(host, 9160));
		protocol = new TBinaryProtocol(transport);
		client = new Cassandra.Client(protocol);
		transport.open();

		// Set the keyspace we are using.
		client.set_keyspace("CDM");

		// Need to find the highest numbered node	
		int highNode = getHighNode();
		System.out.println("High node is " + highNode);
		
		// Copy the Edges to the TC graph
		for (int i = 1; i <= highNode; ++i) {
			ByteBuffer query = ByteBuffer.wrap(("SELECT end FROM Edges WHERE start = " + i + ";").getBytes());
			CqlResult results = client.execute_cql_query(query, Compression.NONE);
			for (CqlRow row : results.getRows()) {
				for (Column col : row.getColumns()) {
					String name = decoder.decode(col.name).toString();
					String value = decoder.decode(col.value).toString();
					if (name.contentEquals("end")) {
						query = ByteBuffer.wrap(("INSERT INTO TC (key, start, end) VALUES (" + i + "-" + value + "," + i + "," + value +");").getBytes());
					}
				}
			}
		}
		
		int[][] node_list = new int[highNode][highNode];
		int start_node = 0;
		int end_node = 0;
		
		// Initialize, we can always get to ourself
		for (int i = 0; i < highNode; ++i) {
				node_list[i][i] = 1;
		}
		
		// Set the Edge query and execute.
		ByteBuffer query = ByteBuffer.wrap("SELECT start, end FROM Edges;".getBytes());
		CqlResult results = client.execute_cql_query(query, Compression.NONE);
		
		// Go through all the edges and set the weights equal to 1
		for (CqlRow row : results.getRows()) {
			for (Column col : row.getColumns()) {
				if (decoder.decode(col.name).toString().contentEquals("start")) {
					start_node = Integer.parseInt(decoder.decode(col.value).toString()) - 1;
				} else {
					end_node = Integer.parseInt(decoder.decode(col.value).toString()) - 1;
				}
			}
			node_list[start_node][end_node] = 1;
			
		}
				
		transport.flush();
		transport.close();
		
		// Print out what we've got.		
		System.out.print("\t");
		for (int i = 0; i < highNode; ++i) {
			System.out.print("\t" + (i+1) + ":");
		}
		System.out.print("\n");
		
		for (int i = 0; i < node_list.length; ++i ) {
			System.out.print(i + "\t|");
			for (int j = 0; j < node_list.length; ++j) {
				System.out.print("\t" + node_list[i][j]);
			}
			System.out.print("\n");
		}
		
		
		// Calculate the transitive closure.
		
		/*
		 * All paths are equal in this implementation.
		 * Paths are directed.
		 * 0 = no path.
		 */
		for (int k = 0; k < highNode; ++k) {
			for (int i = 0; i < highNode; ++i) {
				for (int j = 0; j < highNode; ++j) {
					if (node_list[i][k] + node_list[k][j] == 2) { // This is a path from [i][k] to [k][j]
						node_list[i][j] = 1;
					}
				}
			}
		}
		
		
		// Print out the results of the closure.
		System.out.print("\n\t");
		for (int i = 0; i < highNode; ++i) {
			System.out.print("\t" + (i + 1) + ":");
		}
		System.out.print("\n");
		
		for (int i = 0; i < node_list.length; ++i ) {
			System.out.print((i+1) + "\t|");
			for (int j = 0; j < node_list.length; ++j) {
				System.out.print("\t" + node_list[i][j]);
			}
			System.out.print("\n");
		}
		

	}


	private static int getHighNode() throws Exception{
		ByteBuffer query = ByteBuffer.wrap("SELECT key FROM Nodes;".getBytes());
		CqlResult results = client.execute_cql_query(query, Compression.NONE);
		int high = 0;
		
		// Go through the results and find the highest numbered node
		for (CqlRow row : results.getRows()) {
			for (Column col : row.getColumns()) {
				String name = decoder.decode(col.name).toString();
				int value = Integer.parseInt(decoder.decode(col.value).toString());
				if (name.contentEquals("key")) {
					if (value > high) high = value;
				}
			}
		}
		
		return high;
	}
}
