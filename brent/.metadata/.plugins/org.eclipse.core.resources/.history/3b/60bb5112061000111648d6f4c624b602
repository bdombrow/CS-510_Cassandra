/*
 * Brute force bridges.
 */

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.nio.ByteBuffer;
import java.nio.charset.Charset;
import java.nio.charset.CharsetDecoder;
import java.util.List;

import org.apache.cassandra.thrift.*;
import org.apache.thrift.protocol.TProtocol;
import org.apache.thrift.transport.TFramedTransport;
import org.apache.thrift.transport.TTransport;
import org.apache.thrift.transport.TSocket;


public class sb1 {
	static String host = "localhost";
	static int port = 9160;
	static boolean undirected = true;

	public static void main(String[] args) throws Exception {

		if (args.length == 1) {
			host = args[0];
		}

		// Need to find the highest numbered node	
		int highNode = 14;
		int[][] nodeList = new int[highNode][highNode];


		// Initialize, we can always get to ourself
		for (int i = 0; i < highNode; ++i) {
			nodeList[i][i] = 1; // 0 is being used as infinity. This needs to be smaller than any of the weights.
		}

		// Get the edge weights
		getEdges(nodeList);

		// Print out what we've got.		
		printArray(nodeList);	

		// Calculate the transitive closure.
		int[][] ref = (int[][]) deepCopy(nodeList);
		transC(ref);	

		// Print out the results of the closure.
		printArray(ref);

		// Bridge test, should print nothing.
		System.out.println("Test 1");
		transDiff(ref, ref);

		// Test known bridge
		nodeList[8][9] = 0;
		nodeList[9][8] = 0;

		int[][] trans = (int[][]) deepCopy(nodeList);
		transC(trans);
		System.out.println("\nTest 2");
		if (transDiff(ref, trans)) {
			printArray(trans);
		}

	}

	private static void printArray(int[][] array) {
		System.out.print("\n\t");
		for (int i = 0; i < array.length; ++i) {
			System.out.print("\t" + (i + 1) + ":");
		}
		System.out.print("\n");

		for (int i = 0; i < array.length; ++i ) {
			System.out.print((i+1) + "\t|");
			for (int j = 0; j < array.length; ++j) {
				System.out.print("\t" + array[i][j]);
			}
			System.out.print("\n");
		}
	}

	private static boolean transDiff(int[][] ref, int[][] trans) {
		for (int i = 0; i < ref.length; ++i) {
			for (int j = 0; j < ref.length; ++j) {
				if(ref[i][j] != trans[i][j]) { // We have a bridge
					return true; 
				} 
			}
		}
	return false;
	}

	private static void transC(int[][] inputArray) {
		// 0 = no path
		for (int k = 0; k < inputArray.length; ++k) {
			for (int i = 0; i < inputArray.length; ++i) {
				for (int j = 0; j < inputArray.length; ++j) {
					if (inputArray[i][k] + inputArray[k][j] == 2) { // This is a path from [i][k] to [k][j]
						inputArray[i][j] = 1;
					}
				}
			}

		}			
	}

	private static void getEdges(int[][] inputArray) throws Exception{		
		int start_node = 0;
		int end_node = 0;
		// Set up decoder.
		Charset charset = Charset.forName("UTF-8");
		CharsetDecoder decoder = charset.newDecoder();

		// Set up connection.
		TTransport transport = new TFramedTransport(new TSocket(host, port));
		TProtocol protocol = new TBinaryProtocol(transport);
		Cassandra.Client client = new Cassandra.Client(protocol);
		transport.open();

		// Set the keyspace we are using.
		client.set_keyspace("CDM");

		// Set the edge query and execute.
		ByteBuffer query = ByteBuffer.wrap("SELECT start, end FROM WEdges;".getBytes());
		CqlResult results = client.execute_cql_query(query, Compression.NONE);

		// Go through all the edges and set the weights equal to 1
		List<CqlRow> rows = results.getRows();
		for (CqlRow row : rows) {
			List<Column> columns = row.getColumns();
			for (Column col : columns) {
				String colName = decoder.decode(col.name).toString();
				String colValue = decoder.decode(col.value).toString();

				if (colName.contentEquals("start")) {
					start_node = Integer.parseInt(colValue) - 1;
				}
				if (colName.contentEquals("end")){
					end_node = Integer.parseInt(colValue) - 1;
				}
			}
			inputArray[start_node][end_node] = 1;
			if (undirected) inputArray[end_node][start_node] = 1;

		}

		transport.flush();
		transport.close();
	}

	/* Object cloner taken from http://www.javaworld.com/javaworld/javatips/jw-javatip76.html?page=2
	 * 
	 */

	static public Object deepCopy(Object oldObj) throws Exception
	{
		ObjectOutputStream oos = null;
		ObjectInputStream ois = null;
		try
		{
			ByteArrayOutputStream bos = 
					new ByteArrayOutputStream(); // A
			oos = new ObjectOutputStream(bos); // B
			// serialize and pass the object
			oos.writeObject(oldObj);   // C
			oos.flush();               // D
			ByteArrayInputStream bin = 
					new ByteArrayInputStream(bos.toByteArray()); // E
			ois = new ObjectInputStream(bin);                  // F
			// return the new object
			return ois.readObject(); // G
		}
		catch(Exception e)
		{
			System.out.println("Exception in ObjectCloner = " + e);
			throw(e);
		}
		finally
		{
			oos.close();
			ois.close();
		}
	}
}
